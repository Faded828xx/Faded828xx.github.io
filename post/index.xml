<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Faded828xx Blog</title>
    <link>https://faded828xx.github.io/post/</link>
    <description>Recent content in Posts on Faded828xx Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 13 May 2021 22:10:36 +0800</lastBuildDate><atom:link href="https://faded828xx.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>豆瓣scrapy</title>
      <link>https://faded828xx.github.io/post/%E8%B1%86%E7%93%A3scrapy/</link>
      <pubDate>Thu, 13 May 2021 22:10:36 +0800</pubDate>
      
      <guid>https://faded828xx.github.io/post/%E8%B1%86%E7%93%A3scrapy/</guid>
      <description>用scrapy实现先前的豆瓣爬虫，这里爬了top250，但是结果不是预期的顺序。
import scrapy from scrapy_demo.items import MovieItem class DoubanSpider(scrapy.Spider): name = &#39;douban&#39; allowed_domains = [&#39;douban.com&#39;] start_urls = [ &#39;https://movie.douban.com/top250&#39;, ] def parse(self, response): for i in range(0, 9): url = response.urljoin(&#39;?start=&#39; + str(25 * i)) yield scrapy.Request(url, callback=self.parse_dir_contents) def parse_dir_contents(self, response): # file = &#39;movie.html&#39; # 新建html页面并将爬取到的页面写入其中 # open(file, &#39;w&#39;).write(str(response.body.decode(&#39;utf-8&#39;))) # html = str(response.body.decode(&#39;utf-8&#39;)) # bs = bs4.BeautifulSoup(html, &#39;html.parser&#39;) # for movie in bs.find_all(&#39;div&#39;, class_=&#39;item&#39;): # item = MovieItem() # movie = str(movie) # 每部电影信息 # movielink = re.</description>
    </item>
    
    <item>
      <title>Leetcode1723完成所有工作的最短时间</title>
      <link>https://faded828xx.github.io/post/leetcode1723%E5%AE%8C%E6%88%90%E6%89%80%E6%9C%89%E5%B7%A5%E4%BD%9C%E7%9A%84%E6%9C%80%E7%9F%AD%E6%97%B6%E9%97%B4/</link>
      <pubDate>Sat, 08 May 2021 14:23:16 +0800</pubDate>
      
      <guid>https://faded828xx.github.io/post/leetcode1723%E5%AE%8C%E6%88%90%E6%89%80%E6%9C%89%E5%B7%A5%E4%BD%9C%E7%9A%84%E6%9C%80%E7%9F%AD%E6%97%B6%E9%97%B4/</guid>
      <description>五一去苏州玩了，然后回了趟家。最近在读CSAPP，博客落了一段时间。GoLang啥时候能捡起来啊 手动/facepalm 这里贴一篇力扣的每日一题，是道困难题。
public static int res = Integer.MAX_VALUE; public static int minimumTimeRequired(int[] jobs, int k) { backtrack(jobs, 0, new int[k], 0); return res; } /** * @param jobs 工作量 * @param jobIndex 当前待分配工作索引 * @param jobTime 员工工作分配 * @param curMax 当前分配情况的res值 */ public static void backtrack(int[] jobs, int jobIndex, int[] jobTime, int curMax) { if (jobIndex == jobs.length) { res = Math.min(res, curMax); return; } // 无序分配 因此多个员工分配量都为0时 任选其一即可 boolean flag = true; for (int i = 0; i &amp;lt; jobTime.</description>
    </item>
    
    <item>
      <title>背包问题一</title>
      <link>https://faded828xx.github.io/post/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E4%B8%80/</link>
      <pubDate>Sun, 25 Apr 2021 16:49:37 +0800</pubDate>
      
      <guid>https://faded828xx.github.io/post/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E4%B8%80/</guid>
      <description>这几天力扣每日一题尽是动态规划，气死了，这里总结一下刷题中背包问题的基本解法。力扣链接
问题形式多种多样，但本质上就是对给定数组取有序或无序排列，又或者是这个排列的长度或数量，其解决思路主要考虑三个点：
 给定数组元素可取一次还是多次，即0-1背包还是完全背包，体现在遍历target时是倒叙还是正序 排列是有序还是无序，体现在外循环是nums数组（无序）还是target（有序） 具体问题：组合问题，true false（还没做到），最大最小问题  具体题目可以看这几天github上力扣项目的提交，都在DP分类里面。</description>
    </item>
    
    <item>
      <title>字符串模式匹配</title>
      <link>https://faded828xx.github.io/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</link>
      <pubDate>Tue, 20 Apr 2021 19:14:55 +0800</pubDate>
      
      <guid>https://faded828xx.github.io/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</guid>
      <description>字符串模式匹配问题再经典不过了，暴力和API调用就不再赘述了。之前学的是RK算法，用的是Hash，还看了Java的indexOf源码，今天正好力扣每日一题又刷到，来学习大名鼎鼎的KMP算法。直接上代码：
// KMP字符串匹配 利用前缀数组 当不匹配时 忽略已匹配字符中的相同前后缀 public int strStr(String haystack, String needle) { int lenS = haystack.length(); int lenN = needle.length(); if(lenN==0) return 0; int[] next = new int[lenN]; // needle的前缀数组 最长公共前后缀 for(int i=1, j=0; i&amp;lt;lenN; i++) { // 更新needle的前缀数组 while(j&amp;gt;0 &amp;amp;&amp;amp; needle.charAt(i)!=needle.charAt(j)) { // 若next[i]与next[j]不相等 则next[i]&amp;lt;=next[i-1] j = next[j-1]; } if(needle.charAt(i)==needle.charAt(j)) // next[i]与next[j]相等 则next[i]=next[i-1]+1 j++; next[i] = j; // i为索引 j为前缀的长度 } for(int i=0, j=0; i&amp;lt;lenS; i++) { // 开始匹配 i为haystack索引 j为needle中已匹配字符数 while(j&amp;gt;0 &amp;amp;&amp;amp; haystack.</description>
    </item>
    
    <item>
      <title>豆瓣小爬虫</title>
      <link>https://faded828xx.github.io/post/%E8%B1%86%E7%93%A3%E5%B0%8F%E7%88%AC%E8%99%AB/</link>
      <pubDate>Sun, 18 Apr 2021 14:29:53 +0800</pubDate>
      
      <guid>https://faded828xx.github.io/post/%E8%B1%86%E7%93%A3%E5%B0%8F%E7%88%AC%E8%99%AB/</guid>
      <description>urllib爬取豆瓣网站
bs4解析html页面，获取有用信息并封装到数组中
sqlite3数据库，将数组存入其中
flask框架作为服务器，路由url地址到指定html页面，并从数据库取出变量动态写入页面
import re import sqlite3 import urllib.request import bs4 from flask import Flask, render_template import ssl ssl._create_default_https_context = ssl.SSLContext app = Flask(__name__) @app.route(&#39;/movie&#39;) def movie(): movies = saveDB() return render_template(&#39;movie.html&#39;, movies=movies) if __name__ == &#39;__main__&#39;: app.run() def getData(): # 返回25部电影数组 html = getHtml(&#39;https://movie.douban.com/top250&#39;) bs = bs4.BeautifulSoup(html, &#39;html.parser&#39;) datalist = [] # 存储25部电影 for item in bs.find_all(&#39;div&#39;, class_=&#39;item&#39;): data = [] item = str(item) # 每部电影信息 movielink = re.</description>
    </item>
    
    <item>
      <title>Hugo建站</title>
      <link>https://faded828xx.github.io/post/hugo%E5%BB%BA%E7%AB%99/</link>
      <pubDate>Fri, 16 Apr 2021 19:26:10 +0800</pubDate>
      
      <guid>https://faded828xx.github.io/post/hugo%E5%BB%BA%E7%AB%99/</guid>
      <description>Hugo是go开发的，用于为Github Pages生成静态网站，在本地编辑markdown文件后push到git仓库，username.github.io便会自动更新博客。Hugo据说相比其他工具比如Hexo等轻量化，且提供了许多主题。
hugo new site hugo_hugo.386_blog cd hugo_hugo.386_blog git clone https://gitlab.com/maxlefou/hugo.386 themes/hugo.386 hugo new post/First.md hugo server -t hugo.386 --buildDrafts hugo --theme=hugo.386 --baseUrl=&amp;quot;https://faded828xx.github.io/&amp;quot; --buildDrafts git init git add . git commit -m &amp;quot;first commit: hugo blog&amp;quot; git remote add origin https://github.com/faded828xx/faded828xx.github.io.git git push -u origin master </description>
    </item>
    
  </channel>
</rss>
